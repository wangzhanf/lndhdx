# 前端库框架：

## jQuery库 + BootStrap框架 + Vue框架（基础） + Axios库

## 以Vue路由为例：（配置路由规则+传参） + （动态编程+RESTful）

# 后端框架：



# 衔接产品：依赖管理

## 后端依赖maven    ，   前端依赖   npm  （node package managerment），   node是JavaScript实现，做客户端以及服务器编程。



# 使用Vue脚手架开发

## 脚手架：项目构建工具平台，管理工具和构建组成。

## 前端项目：Saas /  webpack   /  Es6    

## 1	安装node.js   ,    附带安装npm工具

```cmd
node -v
npm -v
```

## 2	配置国内镜像

![image-20221122082859415](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122082859415.png)

所有使用npm的时候，使用cnpm替代

## 3	关于Vue-cli

Vue的脚手架，Vue官方提供的。

```shell
cnpm install -g  @vue/cli
vue -V
```

## 4	通过脚手架创建自己的前端项目

```shell
vue  create    项目名称
建议采用    default  vue2  版本
```

## 5	认识项目开发目录

![image-20221122085310453](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085310453.png)

## 6	运行调试

![image-20221122085402906](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085402906.png)

![image-20221122085647163](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085647163.png)

## 7	打包发布

```shell
npm run build
```

存放在dist目录













# 课后作业：将脚手架项目  day20221122  修改为todoList  【第3版】 ，   手工多组件实现【第2版】



# 选题

## 截止日期：周五之前

## 题目：符合   综合性   原则

## 覆盖度：  专业   ，  核心课程 （前端，前端框架，后端，后端框架，软件测试）

## 建议： 基于        软件项目工程管理在    LOC【泛化】 设计和应用。

## 【偷偷建议】：找开源的 SSM或springBoot项目（Github）

## 等审核通过：实现项目 （熟悉项目），编写论文--必须改动。 





# maven

## 构建工具，依赖工具

## 常见构建工具： npm--JavaScript    ，    make--C，C++  ，ant   ，maven--java，gradle--java家族

##  Maven基于约定优于配置的原则：没有配置按照默认

![image-20221122133658640](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122133658640.png)

![image-20221122134008769](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122134008769.png)





# Maven的使用

## 1	下载解压【非中文特殊字符目录】

https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.zip

maven 是java实现 

## 2	配置环境变量

2.1	JDK的环境变量



2.2	Maven的环境变量

![image-20221122141638021](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122141638021.png)

## 3	验证（重开命令行工具）

![image-20221122141911002](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122141911002.png)

## 4	修改配置文件

配置本地仓库位置

![image-20221122142535467](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122142535467.png)

配置阿里镜像仓库

![image-20221122142608846](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122142608846.png)

## 5	手工创建项目结构

![image-20221122143237108](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122143237108.png)

修改pom.xml

```xml
<project  xmlns="http://maven.apache.org/POM/4.0.0" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                              http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- 域名反写 -->
    <groupId>vip.epss</groupId>
    <!-- 项目名称 -->
    <artifactId>manMaven</artifactId>
    <!-- 版本 -->
    <version>0.1.snapshot</version>
    <!-- 打包方式 pom，jar，war-->
    <packaging>jar</packaging>
    <!-- 这里添加项目依赖的jar包 -->
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <!-- 依赖范围 -->
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

## 6	使用mvn命令构建项目

进入pom.xml所在目录

mvn    deploy   在本地仓库找到打包的内容







# 20221123上课回顾

## 依赖：本质上就是避免重复造轮子。   构建：工程化项目化进行开发。 

## 前端依赖管理：npm，由node.js    ,   cnpm   ,  vue/cli

```shell
cnpm install -g @vue/cli
vue create project1
vue run serve
vue run build

```

把多个组件分离成不同的   .vue   后缀文件  ， 借助于脚手架编译成最终的SPA【webpack】，

命令行优势： 脚本化 

## 后端依赖管理：maven

maven 是由java开发的，配置jdk

生命周期：   clean     ，   complier   ，   test   ，   package   ，report   ，   deploye

```mvn
mvn clean 
mvn test
mvn deploye
```



## 手工创建项目结构：繁琐

解决办法：使用maven的骨架   创建项目

```shell
mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4
```

![image-20221123082916337](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221123082916337.png)



使用IDE打开项目目录







# IDE工具使用独立的maven【idea 为例】

# idea中project认为是一个根module，仅用以组织其他module

## 1	创建project  ，  删除   src  目录，  修改  pom.xml   的   packaging  为   pom  即可 

## 2	创建不同的module

## 3	对父操作等同于对所有的子操作



# 后端框架的初识

## MyBatis：DAO层框架

## Spring：Service层框架

## Spring-MVC：Controller层框架



# MyBatis框架

## ORM思想---Object   Realational  Model

|      | 表   | 类       |
| ---- | ---- | -------- |
|      | 字段 | 属性     |
|      | 值   | 属性的值 |
|      | 记录 | 对象     |

当下主流DAO层框架 基本都符合   ORM  ，     MyBatis   自动封装



**输入映射和输出映射**   ，   和java实体类映射   ，XML配置文件或注解



# 案例1

## 1	导入依赖包，发布资源文件

```xml
<dependencies>
        <!--        mysql 数据库依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.31</version>
        </dependency>
        <!--        mybatis依赖-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.8</version>
        </dependency>
        <!--S        Lombok插件依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.10</version>
            <scope>provided</scope>
        </dependency>
        <!--E        Lombok插件依赖-->
        <!-- 使用log4j输出更多的日志信息 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>
    <build>
        <finalName>day20221123</finalName>

        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
```

## 2	创建mybatis的主配置文件【建议放在resources目录，后期mybatis配置文件会被spring监管】

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 配置数据源相关属性和事务 -->
    <environments default="development">
        <!-- 可以配置多个数据源环境，默认使用default中的值 -->
        <environment id="development">
            <!-- 使用jdbc的事务管理 -->
            <transactionManager type="JDBC" />
            <!-- 配置数据源，并使用自带数据库连接池 -->
            <dataSource type="POOLED">
<!--                mysql 5.7 以前 com.mysql.jdbc.Driver 8以后用  com.mysql.cj.jdbc.Driver-->
                <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                <property name="url"
                          value="jdbc:mysql://localhost:3331/llg?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true" />
                <property name="username" value="root" />
                <property name="password" value="111111" />
            </dataSource>
        </environment>
<!--        运维的环境-->
        <environment id="run">
            <!-- 使用jdbc的事务管理 -->
            <transactionManager type="JDBC" />
            <!-- 配置数据源，并使用自带数据库连接池 -->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                <property name="url"
                          value="jdbc:mysql://localhost:3331/abc?characterEncoding=utf-8" />
                <property name="username" value="root" />
                <property name="password" value="123" />
            </dataSource>
        </environment>
    </environments>
    <!-- 配置映射文件，可配置多个  ,  SQL语句和java方法的映射文件 -->
    <mappers>
<!--        映射单个文件-->
<!--        推荐方式， xml SQL配置文件和Dao接口文件放在同一目录-->
<!--        <mapper class="vip.epss.dao.BusinessDao"></mapper>-->
<!--        <mapper resource="vip.epss.dao.BusinessDao.xml" />-->

<!--        映射多个文件-->
        <package name="vip.epss.dao"/>
<!--        <mapper resource="com/neusoft/po/Emp.xml" />-->
    </mappers>
</configuration>
```

## 3	为了能够实现java对象到数据表的双向自动映射， 创建java  Entry类（pojo）类

推荐使用   lombok插件实现

```java
package vip.epss.pojo;

import lombok.*;

import java.io.Serializable;
import java.sql.Timestamp;

/*
* 1 实现序列化接口
* 2 成员属性对应数据表的字段，数据类型要兼容
* 3 持有映射的对象
* 4 提供空参和必选参数的构造
* 5 提供getter和setter【setter建议返回this对象】
* 6 覆写toString方法方便测试
* */
@Getter
@Setter
@NoArgsConstructor
@ToString
public class Business implements Serializable {
    private Integer id;
    private String password;
    private String businessName;
    private String businessAddress;
    private String businessExplain;
    private Double starPrice;
    private Double deliveryPrice;
    private Integer aid;
    //如果存在多表关系
    private Admin admin;
    private Timestamp uptime;


    public Business(String password, String businessName) {
        this.password = password;
        this.businessName = businessName;
    }

}

```

测试代码

```java
import org.junit.Test;
import vip.epss.pojo.Business;

public class LombokTest {
    public static void main(String[] args) {
        Business business = new Business();
        business.setId(2);
        System.out.println(business);
    }

    @Test
    public void testLombok(){
        Business business = new Business();
        business.setId(2);
        System.out.println(business);
    }
}

```

## 4	创建了xml映射文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace值  接口名称 -->
<mapper namespace="vip.epss.dao.BusinessDao">
<!--
    id   对应   接口中的  方法名
    parameterType   对应   方法的传入参数类型
    #{变量名}      实现参数的引用   , 基本类型变量名任意  ， 复合类型不可以
    resultType      对应   方法的返回类类型  ,  方法返回基本类型可以不设定 resultType

    public Business selectByPrimaryKey(int id);
-->
    <select id="selectByPrimaryKey" parameterType="int" resultType="vip.epss.pojo.Business">
        select * from business where id=#{value}
    </select>
    <delete id="deleteByPrimaryKey" parameterType="int">
        delete from business where id=#{val}
    </delete>
    <insert id="insertObj" parameterType="vip.epss.pojo.Business">
        insert into business (password,businessName) values (#{password},#{businessName})
    </insert>
</mapper>
```

## 5	创建接口【无需实现类，框架通过动态代理自动生成实现类】

```java
package vip.epss.dao;

import vip.epss.pojo.Business;


public interface BusinessDao {
    public abstract Business selectByPrimaryKey(Integer id);
    public abstract int deleteByPrimaryKey(Integer id);
    int insertObj(Business obj);
}


```

```java


```

## 6	编写测试方法

```java
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;
import vip.epss.dao.BusinessDao;
import vip.epss.pojo.Business;

import java.io.IOException;
import java.io.Reader;

public class BusinessDaoTest {

    @Test
    public void testSelectByPrimaryKey() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        Business business = mapper.selectByPrimaryKey(1018);
        //输出
        System.out.println(business);
        return;
    }

    @Test
    public void testDeleteByPrimaryKey() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        int i = mapper.deleteByPrimaryKey(14);
        //输出
        System.out.println(i);
        return;
    }

    @Test
    public void testInsert() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        int i = mapper.insertObj(new Business("12345", "花甲粉"));
        //输出
        System.out.println(i);
        return;
    }

}

```



## 7	添加log4j的配置

```xml
### direct log messages to stdout ###
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %m%n
### direct messages to file mylog.log ###
### log4j.appender.file=org.apache.log4j.FileAppender
### log4j.appender.file.File=d:mylog.log
### log4j.appender.file.layout=org.apache.log4j.PatternLayout
### log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %m%n
### set log levels - for more verbose logging change 'debug?info?warn?error' ###
### log4j.rootLogger=debug,stdout,file
log4j.rootLogger=debug,stdout
```

















常见的MyBatis的用法：  创建接口文件    xxxxxxxxDao.java   <<interface>>     ,创建和接口同名的   SQL配置文件     xxxxxxxxDao.xml    ,    mybatis使用动态代理自动生成接口的实现类   【用户无需手工创建实现类】



鉴于钉钉直播延迟严重的问题，   后期课程采用腾讯会议模式    ，     上课代码还是在github发布，   课程录像继续上传到钉钉群，  只是上课采用腾讯会议   ，点击链接入会，或添加至会议列表：
https://meeting.tencent.com/dm/549OcQKiEKN9

#腾讯会议：939-1160-1821



# MyBatis配置的优化

## 1	配置别名映射

## 2	使用独立的数据库配置文件





# 常用数据库操作

## 1	SQL语句是文本形式,注意转义符的问题【 <  >  成对出现时】以及字符串拼接的问题【 concat   SQL函数拼接】

## 2	插入数据时获取刚插入数据的主键信息，返回的主键被封装到插入对象中。【使用场合，多表关联】

## 3	条件查询【动态SQL  取代拼接字符串】





# 使用mybatis逆向工程自动生成

## 【实体类，搜索类，接口，xml配置】

## 根据已经创建的数据表生成对应的java程序【ORM】



# 案例【module的配置】

module中使用逆向需要使用绝对路径方式，   project中使用逆向使用相对路径

## 1	添加依赖包

```xml
<!-- 代码生成工具jar , 逆向工程包-->

        <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
        </dependency>

```

## 2	创建逆向工程的配置文件   xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="testTables" targetRuntime="MyBatis3">
        <commentGenerator>
            <!-- 是否去除自动生成的注释 true：是[建议] ： false:否 -->
            <property name="suppressAllComments" value="true" />
        </commentGenerator>
        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->

        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3331/ele_se?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"
                        userId="root"
                        password="111111">
        </jdbcConnection>

        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和
           NUMERIC 类型解析为java.math.BigDecimal -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>

        <!-- targetProject:生成PO类，包含搜索条件类,pojo，domain ，的位置 -->
        <javaModelGenerator targetPackage="vip.epss.domain" targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
            <!-- 从数据库返回的值被清理前后的空格 -->
            <property name="trimStrings" value="true" />
        </javaModelGenerator>
        <!-- targetProject:mapper映射文件 接口 生成的位置 -->
        <sqlMapGenerator targetPackage="vip.epss.dao"
                         targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
        </sqlMapGenerator>
        <!-- targetPackage：mapper接口生成的位置 -->
        <javaClientGenerator type="XMLMAPPER"
                             targetPackage="vip.epss.dao"
                             targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
        </javaClientGenerator>
        <!-- 指定数据库表， 哪些表生成对应的程序 -->

<!--        <table tableName="admin" domainObjectName="Admin"-->
<!--               enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false"-->
<!--               enableSelectByExample="false" selectByExampleQueryId="false" >-->
<!--            <columnOverride column="id" javaType="Integer" />-->
<!--        </table>-->

        <table tableName="admin" domainObjectName="Admin"></table>
        <table tableName="business" domainObjectName="Business"></table>
        <table tableName="info" domainObjectName="Info"></table>
        <table tableName="food" domainObjectName="Food"></table>
        <table tableName="ordermap" domainObjectName="Ordermap"></table>

    </context>
</generatorConfiguration>

```

## 3	创建逆向工程执行程序【只执行1次】

```java
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class MyBatisGenerater {
    public static void main(String[] args) throws Exception {
        List<String> warnings = new ArrayList<String>();
        boolean overwrite = true;
        File configFile = new File("C:\\myfloder\\授课资料\\辽宁理工职业大学\\code\\08.frame\\frame\\day2022112401\\src\\main\\resources\\mybatisGenerateConfig.xml");
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
        myBatisGenerator.generate(null);
    }
}

```

# 