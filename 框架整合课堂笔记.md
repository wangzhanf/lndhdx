# 上课回顾20221209

## 1	为何使用SpringBoot，简化配置，模板【通过启动器自动构建】

## 2	约定优于配置，引导类只能扫描同包和子包，内置web服务器默认会工作于一个端口

## 3	引导类本质就是扫描Bean，获取IOC容器。







# 热部署

修改代码后无需手动重启即可访问测试【比较消耗资源】

## 1	创建的时候选择热部署工具

![image-20221209085334469](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221209085334469.png)

## 2	在idea中开启热部署功能【存在问题】





# 跨域的处理

## 1	给单个Controller设置跨域

添加    //只要在此Controller上使用@CrossOrigin注解就可实现跨域访问，并可配置允许跨域的url
@CrossOrigin("*") 

## 2	在启动类同级或子包创建配置类，整体设置跨域

```java
package vip.epss.utils;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CROS implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        /*
         * addMapping：配置可以被跨域的路径，可以任意配置，可以具体到直接请求路径。
         * allowCredentials：是否开启Cookie
         * allowedMethods：允许的请求方式，如：POST、GET、PUT、DELETE等。
         * allowedOrigins：允许访问的url，可以固定单条或者多条内容
         * allowedHeaders：允许的请求header，可以自定义设置任意请求头信息。
         * maxAge：配置预检请求的有效时间
         */
        registry
                .addMapping("/**")
                .allowedOrigins("*")
//                .allowCredentials(true)
//                .allowedMethods("*")
//                .allowedHeaders("*")
//                .maxAge(36000)
                ;
    }
}

```

# 课堂练习： 设置站点允许跨域【10：30】





# SpringBoot的配置文件

虽然约定优于配置， 对于个性化的问题还需要配置。传统Spring通过   xxxxxx.xml   进行配置， XML的格式存在缺陷   受格式限制，标记以及属性名占用了太多空间

```xml
<bean id="adminService" class="vip.epss.service.AdminService">
	<property .........></property>
</bean>
```



SpringBoot的配置文件更精简，注重表现数据

application.properties     优先于  application.yml        【类似于CSS】



# 课堂练习：  设置springboot的发布端口和发布应用地址【11：15】







# 程序中使用配置文件中的数据

## 1	@Value  注解 将配置文件的值赋值给  成员属性  【企业名称】

## 2	@Autowired   ， 注入全部配置文件【Environment】  【运维】

## 3	注入配置文件的片段到实体类中  【通过配置文件产生对象】



# 课堂练习：  获取配置文件中的片段值

```
@Component
@ConfigurationProperties(prefix = "person")
```

# 课间休息：【14：00】







# 整合MyBatis

## 1	导入依赖包

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.0.1</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <!-- spring 开头的包都是spring官网提供的，    xxxxx-spring   包  都是被spring收录的 -->
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.31</version>
    <scope>runtime</scope>
</dependency>
```

![image-20221209141105694](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221209141105694.png)



## 2	构建Mapper层功能

```java
package vip.epss.dao;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Repository;
import vip.epss.domain.Admin;

import java.util.List;

//@Component
//@Repository
@Mapper
public interface AdminDao {
    @Select("select * from admin where id=#{vvvvvvvvaaaall}")
    Admin selectByPrimaryKey(Integer id);

    @Select("select * from admin")
    List<Admin> selectByExample();
}

```

## 3	Controller代码

```java
package vip.epss.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import vip.epss.dao.AdminDao;
import vip.epss.domain.Admin;

@RestController
@RequestMapping("admins")
public class AdminController {

    @Autowired
    private AdminDao adminDao;

    @GetMapping
    public String test(){
        Admin admin = adminDao.selectByPrimaryKey(1);
        System.out.println(admin);
        System.out.println("--------------------------------");
        for (Admin admin1 : adminDao.selectByExample()) {
            System.out.println(admin1);
        }


        return "success";
    }
}

```

## 4	配置文件

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3331/ele_se?characterEncoding=utf8&useSSL=false&serverTimezone=UTC&rewriteBatchedStatements=true
    username: root
    password: 111111

server:
  port: 80
```

# 课堂练习：整合MyBatis实现业务【15：00】









# 需要解决的问题

## 1	如何进行Controller接口测试？   postman

## 2	合理的调试程序？日志切入







# 课堂练习：   实现admin实体资源的操作，    dao层的增删改查（1个，所有），   controller层通过不同的接口【REST风格  http://localhost/admins/[id]    】给用户提供操作admin的方法。测试人员通过postman测试接口，也可以定时自动开启测试。【9：45】

## 新的需求： 知道接口能够承担多大的并发



# 自动化测试

## 1	功能测试

postman

## 2	性能测试

在核定资源内，能够产生的生产力。

性能指标评价生产力： 速度、吞吐率、负载，极限（极限*0.8 = 压力），并发和并行

![image-20221211095924899](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211095924899.png)

通过多个线程模拟多个用户同时并发访问

可以使用测试据模拟多线程。   HP（LoadRunner）     Apache（Jmeter）



# 3	JMeter的安装和使用

JMeter是Java实现的， 跨平台， 需要java虚拟机支持



## 3.1	下载并解压到非中文非特殊字符目录

https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.5.zip



## 3.2	配置环境变量【定位到java虚拟机】



![image-20221211102926737](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211102926737.png)



## 3.3	测试JDK以及jmeter是否正常工作

![image-20221211103623579](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211103623579.png)





## 课堂练习： 安装并配置JMeter【10：50】



## 3.4	认知JMeter结构

![image-20221211110825627](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211110825627.png)



## 3.5	修改配置【在bin目录】

![image-20221211111327798](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211111327798.png)

![image-20221211111635595](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211111635595.png)

## 3.6	如何运行jar包   【课堂练习：11：40】

![image-20221211112128771](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211112128771.png)









# 使用JMeter

## 1	创建测试计划

将测试计划保存   xxxx.jmx   可以多次复用

## 2	创建一个线程组【模拟多用户】

一般创建     普通线程组   

![image-20221211115043565](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211115043565.png)

## 3	添加取样器【不同的测试使用不同的取样器】

![image-20221211115500855](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211115500855.png)

## 4	添加监听器【查看结果和分析结果】

![image-20221211115920362](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211115920362.png)

注意： 取样器的顺序决定了测试的顺序，   监听器是针对于取样数据进行分析整理的， 监听器针对当前单元的监听【顺序不重要】





# 课堂实践： 测试  REST  的五个接口【13：40】



# JMeter测试数据库

## 1	下载数据库的驱动， 拷贝到   jmeter安装目录下的   lib下

以MySQL为例：   mysql-connector-java.jar

![image-20221211135359942](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211135359942.png)

## 2	将驱动加载到测试计划中并重启

![image-20221211135610224](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211135610224.png)

## 3	添加“元件”（可重复复用的） ，  JDBC Connection Configuration

![image-20221211141315909](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211141315909.png)

## 4	添加  取样器   

![image-20221211141505441](%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221211141505441.png)

# 课间休息：  14：25