# 前端库框架：

## jQuery库 + BootStrap框架 + Vue框架（基础） + Axios库

## 以Vue路由为例：（配置路由规则+传参） + （动态编程+RESTful）

# 后端框架：



# 衔接产品：依赖管理

## 后端依赖maven    ，   前端依赖   npm  （node package managerment），   node是JavaScript实现，做客户端以及服务器编程。



# 使用Vue脚手架开发

## 脚手架：项目构建工具平台，管理工具和构建组成。

## 前端项目：Saas /  webpack   /  Es6    

## 1	安装node.js   ,    附带安装npm工具

```cmd
node -v
npm -v
```

## 2	配置国内镜像

![image-20221122082859415](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122082859415.png)

所有使用npm的时候，使用cnpm替代

## 3	关于Vue-cli

Vue的脚手架，Vue官方提供的。

```shell
cnpm install -g  @vue/cli
vue -V
```

## 4	通过脚手架创建自己的前端项目

```shell
vue  create    项目名称
建议采用    default  vue2  版本
```

## 5	认识项目开发目录

![image-20221122085310453](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085310453.png)

## 6	运行调试

![image-20221122085402906](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085402906.png)

![image-20221122085647163](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122085647163.png)

## 7	打包发布

```shell
npm run build
```

存放在dist目录













# 课后作业：将脚手架项目  day20221122  修改为todoList  【第3版】 ，   手工多组件实现【第2版】



# 选题

## 截止日期：周五之前

## 题目：符合   综合性   原则

## 覆盖度：  专业   ，  核心课程 （前端，前端框架，后端，后端框架，软件测试）

## 建议： 基于        软件项目工程管理在    LOC【泛化】 设计和应用。

## 【偷偷建议】：找开源的 SSM或springBoot项目（Github）

## 等审核通过：实现项目 （熟悉项目），编写论文--必须改动。 





# maven

## 构建工具，依赖工具

## 常见构建工具： npm--JavaScript    ，    make--C，C++  ，ant   ，maven--java，gradle--java家族

##  Maven基于约定优于配置的原则：没有配置按照默认

![image-20221122133658640](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122133658640.png)

![image-20221122134008769](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122134008769.png)





# Maven的使用

## 1	下载解压【非中文特殊字符目录】

https://dlcdn.apache.org/maven/maven-3/3.8.6/binaries/apache-maven-3.8.6-bin.zip

maven 是java实现 

## 2	配置环境变量

2.1	JDK的环境变量



2.2	Maven的环境变量

![image-20221122141638021](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122141638021.png)

## 3	验证（重开命令行工具）

![image-20221122141911002](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122141911002.png)

## 4	修改配置文件

配置本地仓库位置

![image-20221122142535467](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122142535467.png)

配置阿里镜像仓库

![image-20221122142608846](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122142608846.png)

## 5	手工创建项目结构

![image-20221122143237108](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221122143237108.png)

修改pom.xml

```xml
<project  xmlns="http://maven.apache.org/POM/4.0.0" 
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                              http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- 域名反写 -->
    <groupId>vip.epss</groupId>
    <!-- 项目名称 -->
    <artifactId>manMaven</artifactId>
    <!-- 版本 -->
    <version>0.1.snapshot</version>
    <!-- 打包方式 pom，jar，war-->
    <packaging>jar</packaging>
    <!-- 这里添加项目依赖的jar包 -->
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <!-- 依赖范围 -->
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
```

## 6	使用mvn命令构建项目

进入pom.xml所在目录

mvn    deploy   在本地仓库找到打包的内容







# 20221123上课回顾

## 依赖：本质上就是避免重复造轮子。   构建：工程化项目化进行开发。 

## 前端依赖管理：npm，由node.js    ,   cnpm   ,  vue/cli

```shell
cnpm install -g @vue/cli
vue create project1
vue run serve
vue run build

```

把多个组件分离成不同的   .vue   后缀文件  ， 借助于脚手架编译成最终的SPA【webpack】，

命令行优势： 脚本化 

## 后端依赖管理：maven

maven 是由java开发的，配置jdk

生命周期：   clean     ，   complier   ，   test   ，   package   ，report   ，   deploye

```mvn
mvn clean 
mvn test
mvn deploye
```



## 手工创建项目结构：繁琐

解决办法：使用maven的骨架   创建项目

```shell
mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4
```

![image-20221123082916337](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221123082916337.png)



使用IDE打开项目目录







# IDE工具使用独立的maven【idea 为例】

# idea中project认为是一个根module，仅用以组织其他module

## 1	创建project  ，  删除   src  目录，  修改  pom.xml   的   packaging  为   pom  即可 

## 2	创建不同的module

## 3	对父操作等同于对所有的子操作



# 后端框架的初识

## MyBatis：DAO层框架

## Spring：Service层框架

## Spring-MVC：Controller层框架



# MyBatis框架

## ORM思想---Object   Realational  Model

|      | 表   | 类       |
| ---- | ---- | -------- |
|      | 字段 | 属性     |
|      | 值   | 属性的值 |
|      | 记录 | 对象     |

当下主流DAO层框架 基本都符合   ORM  ，     MyBatis   自动封装



**输入映射和输出映射**   ，   和java实体类映射   ，XML配置文件或注解



# 案例1

## 1	导入依赖包，发布资源文件

```xml
<dependencies>
        <!--        mysql 数据库依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.31</version>
        </dependency>
        <!--        mybatis依赖-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.8</version>
        </dependency>
        <!--S        Lombok插件依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.10</version>
            <scope>provided</scope>
        </dependency>
        <!--E        Lombok插件依赖-->
        <!-- 使用log4j输出更多的日志信息 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>
    <build>
        <finalName>day20221123</finalName>

        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
```

## 2	创建mybatis的主配置文件【建议放在resources目录，后期mybatis配置文件会被spring监管】

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 配置数据源相关属性和事务 -->
    <environments default="development">
        <!-- 可以配置多个数据源环境，默认使用default中的值 -->
        <environment id="development">
            <!-- 使用jdbc的事务管理 -->
            <transactionManager type="JDBC" />
            <!-- 配置数据源，并使用自带数据库连接池 -->
            <dataSource type="POOLED">
<!--                mysql 5.7 以前 com.mysql.jdbc.Driver 8以后用  com.mysql.cj.jdbc.Driver-->
                <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                <property name="url"
                          value="jdbc:mysql://localhost:3331/llg?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true" />
                <property name="username" value="root" />
                <property name="password" value="111111" />
            </dataSource>
        </environment>
<!--        运维的环境-->
        <environment id="run">
            <!-- 使用jdbc的事务管理 -->
            <transactionManager type="JDBC" />
            <!-- 配置数据源，并使用自带数据库连接池 -->
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver" />
                <property name="url"
                          value="jdbc:mysql://localhost:3331/abc?characterEncoding=utf-8" />
                <property name="username" value="root" />
                <property name="password" value="123" />
            </dataSource>
        </environment>
    </environments>
    <!-- 配置映射文件，可配置多个  ,  SQL语句和java方法的映射文件 -->
    <mappers>
<!--        映射单个文件-->
<!--        推荐方式， xml SQL配置文件和Dao接口文件放在同一目录-->
<!--        <mapper class="vip.epss.dao.BusinessDao"></mapper>-->
<!--        <mapper resource="vip.epss.dao.BusinessDao.xml" />-->

<!--        映射多个文件-->
        <package name="vip.epss.dao"/>
<!--        <mapper resource="com/neusoft/po/Emp.xml" />-->
    </mappers>
</configuration>
```

## 3	为了能够实现java对象到数据表的双向自动映射， 创建java  Entry类（pojo）类

推荐使用   lombok插件实现

```java
package vip.epss.pojo;

import lombok.*;

import java.io.Serializable;
import java.sql.Timestamp;

/*
* 1 实现序列化接口
* 2 成员属性对应数据表的字段，数据类型要兼容
* 3 持有映射的对象
* 4 提供空参和必选参数的构造
* 5 提供getter和setter【setter建议返回this对象】
* 6 覆写toString方法方便测试
* */
@Getter
@Setter
@NoArgsConstructor
@ToString
public class Business implements Serializable {
    private Integer id;
    private String password;
    private String businessName;
    private String businessAddress;
    private String businessExplain;
    private Double starPrice;
    private Double deliveryPrice;
    private Integer aid;
    //如果存在多表关系
    private Admin admin;
    private Timestamp uptime;


    public Business(String password, String businessName) {
        this.password = password;
        this.businessName = businessName;
    }

}

```

测试代码

```java
import org.junit.Test;
import vip.epss.pojo.Business;

public class LombokTest {
    public static void main(String[] args) {
        Business business = new Business();
        business.setId(2);
        System.out.println(business);
    }

    @Test
    public void testLombok(){
        Business business = new Business();
        business.setId(2);
        System.out.println(business);
    }
}

```

## 4	创建了xml映射文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace值  接口名称 -->
<mapper namespace="vip.epss.dao.BusinessDao">
<!--
    id   对应   接口中的  方法名
    parameterType   对应   方法的传入参数类型
    #{变量名}      实现参数的引用   , 基本类型变量名任意  ， 复合类型不可以
    resultType      对应   方法的返回类类型  ,  方法返回基本类型可以不设定 resultType

    public Business selectByPrimaryKey(int id);
-->
    <select id="selectByPrimaryKey" parameterType="int" resultType="vip.epss.pojo.Business">
        select * from business where id=#{value}
    </select>
    <delete id="deleteByPrimaryKey" parameterType="int">
        delete from business where id=#{val}
    </delete>
    <insert id="insertObj" parameterType="vip.epss.pojo.Business">
        insert into business (password,businessName) values (#{password},#{businessName})
    </insert>
</mapper>
```

## 5	创建接口【无需实现类，框架通过动态代理自动生成实现类】

```java
package vip.epss.dao;

import vip.epss.pojo.Business;


public interface BusinessDao {
    public abstract Business selectByPrimaryKey(Integer id);
    public abstract int deleteByPrimaryKey(Integer id);
    int insertObj(Business obj);
}


```

```java


```

## 6	编写测试方法

```java
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;
import vip.epss.dao.BusinessDao;
import vip.epss.pojo.Business;

import java.io.IOException;
import java.io.Reader;

public class BusinessDaoTest {

    @Test
    public void testSelectByPrimaryKey() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        Business business = mapper.selectByPrimaryKey(1018);
        //输出
        System.out.println(business);
        return;
    }

    @Test
    public void testDeleteByPrimaryKey() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        int i = mapper.deleteByPrimaryKey(14);
        //输出
        System.out.println(i);
        return;
    }

    @Test
    public void testInsert() throws IOException {
        //挖矿获得资金
        Reader resourceAsReader = Resources.getResourceAsReader("mybatis.xml");
        //使用资金雇佣工人建造工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsReader);
        //使用工厂生产产品 sqlSession   等同于   connection ，true代表  autocommit
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取对应的mapper
        BusinessDao mapper = sqlSession.getMapper(BusinessDao.class);
        //使用mapper执行具体方法
        int i = mapper.insertObj(new Business("12345", "花甲粉"));
        //输出
        System.out.println(i);
        return;
    }

}

```



## 7	添加log4j的配置

```xml
### direct log messages to stdout ###
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %m%n
### direct messages to file mylog.log ###
### log4j.appender.file=org.apache.log4j.FileAppender
### log4j.appender.file.File=d:mylog.log
### log4j.appender.file.layout=org.apache.log4j.PatternLayout
### log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %m%n
### set log levels - for more verbose logging change 'debug?info?warn?error' ###
### log4j.rootLogger=debug,stdout,file
log4j.rootLogger=debug,stdout
```

















常见的MyBatis的用法：  创建接口文件    xxxxxxxxDao.java   <<interface>>     ,创建和接口同名的   SQL配置文件     xxxxxxxxDao.xml    ,    mybatis使用动态代理自动生成接口的实现类   【用户无需手工创建实现类】



鉴于钉钉直播延迟严重的问题，   后期课程采用腾讯会议模式    ，     上课代码还是在github发布，   课程录像继续上传到钉钉群，  只是上课采用腾讯会议   ，点击链接入会，或添加至会议列表：
https://meeting.tencent.com/dm/549OcQKiEKN9

#腾讯会议：939-1160-1821



# MyBatis配置的优化

## 1	配置别名映射

## 2	使用独立的数据库配置文件





# 常用数据库操作

## 1	SQL语句是文本形式,注意转义符的问题【 <  >  成对出现时】以及字符串拼接的问题【 concat   SQL函数拼接】

## 2	插入数据时获取刚插入数据的主键信息，返回的主键被封装到插入对象中。【使用场合，多表关联】

## 3	条件查询【动态SQL  取代拼接字符串】





# 使用mybatis逆向工程自动生成

## 【实体类，搜索类，接口，xml配置】

## 根据已经创建的数据表生成对应的java程序【ORM】



# 案例【module的配置】

module中使用逆向需要使用绝对路径方式，   project中使用逆向使用相对路径

## 1	添加依赖包

```xml
<!-- 代码生成工具jar , 逆向工程包-->

        <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
        </dependency>

```

## 2	创建逆向工程的配置文件   xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <context id="testTables" targetRuntime="MyBatis3">
        <commentGenerator>
            <!-- 是否去除自动生成的注释 true：是[建议] ： false:否 -->
            <property name="suppressAllComments" value="true" />
        </commentGenerator>
        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->

        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"
                        connectionURL="jdbc:mysql://localhost:3331/ele_se?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true"
                        userId="root"
                        password="111111">
        </jdbcConnection>

        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和
           NUMERIC 类型解析为java.math.BigDecimal -->
        <javaTypeResolver>
            <property name="forceBigDecimals" value="false" />
        </javaTypeResolver>

        <!-- targetProject:生成PO类，包含搜索条件类,pojo，domain ，的位置 -->
        <javaModelGenerator targetPackage="vip.epss.domain" targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
            <!-- 从数据库返回的值被清理前后的空格 -->
            <property name="trimStrings" value="true" />
        </javaModelGenerator>
        <!-- targetProject:mapper映射文件 接口 生成的位置 -->
        <sqlMapGenerator targetPackage="vip.epss.dao"
                         targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
        </sqlMapGenerator>
        <!-- targetPackage：mapper接口生成的位置 -->
        <javaClientGenerator type="XMLMAPPER"
                             targetPackage="vip.epss.dao"
                             targetProject="C:\myfloder\授课资料\辽宁理工职业大学\code\08.frame\frame\day2022112401\src\main\java">
            <!-- enableSubPackages:是否让schema作为包的后缀 -->
            <property name="enableSubPackages" value="false" />
        </javaClientGenerator>
        <!-- 指定数据库表， 哪些表生成对应的程序 -->

<!--        <table tableName="admin" domainObjectName="Admin"-->
<!--               enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false"-->
<!--               enableSelectByExample="false" selectByExampleQueryId="false" >-->
<!--            <columnOverride column="id" javaType="Integer" />-->
<!--        </table>-->

        <table tableName="admin" domainObjectName="Admin"></table>
        <table tableName="business" domainObjectName="Business"></table>
        <table tableName="info" domainObjectName="Info"></table>
        <table tableName="food" domainObjectName="Food"></table>
        <table tableName="ordermap" domainObjectName="Ordermap"></table>

    </context>
</generatorConfiguration>

```

## 3	创建逆向工程执行程序【只执行1次】

```java
import org.mybatis.generator.api.MyBatisGenerator;
import org.mybatis.generator.config.Configuration;
import org.mybatis.generator.config.xml.ConfigurationParser;
import org.mybatis.generator.internal.DefaultShellCallback;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class MyBatisGenerater {
    public static void main(String[] args) throws Exception {
        List<String> warnings = new ArrayList<String>();
        boolean overwrite = true;
        File configFile = new File("C:\\myfloder\\授课资料\\辽宁理工职业大学\\code\\08.frame\\frame\\day2022112401\\src\\main\\resources\\mybatisGenerateConfig.xml");
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(configFile);
        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
        myBatisGenerator.generate(null);
    }
}

```

# 

# 上课回顾

前端：HTML+CSS+Javascript				jQuery，BootStrap，Vue
java：编程逻辑					idea
web开发：Servlet+HTTP				SSM，Spring，SpringMvc，MyBatis

MyBatis【ORM思想】
【接口+SQL配置文件】 ==》 通过动态代理生成具体实现类   



# MyBatis加工

通过逆向工程生成的接口，单表操作大概11个方法。【count，insert，insertSelective，deleteByPrimaryKey，deleteByExample，updateByPrimaryKey，updateByExample，updateBySelective，selectByExample，selectByPrimaryKey】

既然可以自动生成，说明存在规律 ，  可以将所有生成的接口统一抽象为一个父接口，子接口通过继承拥有父接口的方法， 类型通过泛型编程指定。

# 课堂练习：对逆向工程生成的mapper接口抽象。：9：00

# 

# Spring家族

Spring框架为基础，模块化添加子模块实现业务应用

因何产生了Spring：传统的JavaEE（企业级）开发 使用  EJB【IBM】（繁琐臃肿）

## Spring的体系结构

![image-20221128092950725](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221128092950725.png)

## Spring的核心

Ioc：Spring的超级工厂，Ioc容器放Bean【配置】，DI自动注入依赖的Bean到Ioc容器

AOP：面向切面编程



## 实现Ioc【DI】通过xml配置文件方式

通用的多层架构，  service调dao【mapper】

```java
class AdminMapper{
    public Admin selectByPrimaryKey(Integer id){
        //进行数据库操作
    }
}

class AdminService{
    //private AdminMapper adminMapper = new AdminMapper();
    
    public void selectOne(){
        adminMapper.selectByPrimaryKey(1);
    }
}
```

# 案例：基于xml配置

## 1	添加依赖

![image-20221128103207513](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221128103207513.png)

## 2	构建分层结构 

推荐基于接口编程

## 3	创建spring的主配置文件 applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
<!--    每个bean的声明都将会被放在IOC容器中-->
<!--    id就是对象名，class就是 类， 相当于Srping的超级工厂生产了一个bean叫做adminMapper并将其放入了IOC容器-->
    <bean id="adminMapper" class="vip.epss.dao.AdminMapper"></bean>
    <bean id="foodMapper" class="vip.epss.dao.FoodMapper"></bean>
    <bean id="adminService" class="vip.epss.service.AdminService">
<!--        property  持有的成员属性对象, 依赖注入，通过ref指向已经在IOC的Bean,默认通过getter和setter注入和使用-->
        <property name="adminMapper" ref="adminMapper"></property>
        <property name="foodMapper" ref="foodMapper"></property>
    </bean>
</beans>
```

## 4	编写测试代码 

```java
import org.springframework.context.support.ClassPathXmlApplicationContext;
import vip.epss.service.AdminService;

public class TestSpringDI {
    public static void main(String[] args) {
        //1 通过读取Spring主配置文件获得IOC容器
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        //2 通过  getBean 方法获得容器中的  bean
//        Object adminService = context.getBean("adminService");
//        AdminService adminService = (AdminService)context.getBean("adminService");
        AdminService adminService = context.getBean("adminService",AdminService.class);
        //3 调用bean的相关方法
        adminService.selectOne(77);
    }
}

```



# 案例：基于注解

## 1	添加spring依赖

## 2	spring主配置文件添加组件扫描

```xml
<context:component-scan base-package="vip.epss"></context:component-scan>
```

## 3	给类添加组件注解@Component，给依赖的对象添加 自动注入@AutoWired注解

## 4	测试程序【拿到IOC容器，拿到对应的Bean】





## 课堂练习：  完成基于注解的spring实现，  语义化注解方式



# Bean的属性

## 1	默认放置在IOC容器中bean，都是单例singleton的，也可以指定为   prototype

## 2	@Qualifier 指定bean名字进行注入【接口和实现类不同名】

# 综合案例：

## 1	改写项目，实现基于接口的编程【多态】

## 2	使用注解实现bean注入

## 3	使用自动扫描添加bean到ioc容器



# 上课回顾

## IOC控制反转  容器，spring超级工厂，DI依赖注入。采用的方式【手工配置xml文件，注解方式（@Repostory，@Service，@Controller，@Component），】









# AOP面向切面编程

面向结构编程【函数式编程】，面向对象编程【链式编程】

将重复的代码抽取，通过动态代理不改变源码对方法进行增强。

AOP是思想，Aspectj是具体实现

## 使用注解实现AOP【理论】

### 1	添加依赖

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <parent>
        <artifactId>frame</artifactId>
        <groupId>vip.epss</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>day20221129</artifactId>
    <packaging>war</packaging>
    <name>day20221129 Maven Webapp</name>
    <url>http://maven.apache.org</url>

    <properties>
        <!-- spring 版本号，便于统一处理多个模块，  -->
        <spring.version>5.2.8.RELEASE</spring.version>
    </properties>

    <dependencies>
        <!--        mysql 数据库依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.31</version>
        </dependency>
        <!--        mybatis依赖-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.8</version>
        </dependency>
        <!--S        Lombok插件依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.10</version>
            <scope>provided</scope>
        </dependency>
        <!--E        Lombok插件依赖-->
        <!-- 使用log4j输出更多的日志信息 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>

        <!-- 代码生成工具jar , 逆向工程包-->

        <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
        </dependency>

        <!-- 此依赖会关联引用Spring中的所有基础jar包，利用了maven自动依赖管理，导入所有的spring的核心包 -->
<!--        核心包：bean，core，context，spEL（Expression）-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>${spring.version}</version>
        </dependency>

<!--        aop的相关依赖-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>${spring.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>${spring.version}</version>
        </dependency>

<!--        aop的织入包-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.7</version>
        </dependency>

    </dependencies>
    <build>
        <finalName>day20221129</finalName>

        <!--        发布资源-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
</project>

```

### 2	编写切入的代码【方面的代码】

```java
package vip.epss.advice;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

//切面的代码，确保他是一个spring组件，还需要声明为 方面的代码
@Component
@Aspect
public class CheckModel {

    //通过注解方式@Before告知将增强方法切入到什么位置【切入点】
    @Before("execution(int vip.epss.service.*.*(..))")
    public void checkCode(){
        System.out.println("进教室先检查健康码........");
    }

    //传统手工调用
//    public static void main(String[] args) {
//        CheckModel checkModel = new CheckModel();
//        checkModel.checkCode();
//    }
}

```

### 3	编写切入点代码【业务代码】

```java
package vip.epss.dao;

import org.springframework.stereotype.Repository;

@Repository(value = "adminMapper")
public class AdminMapper {
    public void test1(){
        System.out.println("AdminMapper  test().......");
    }
}

```

```java
package vip.epss.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import vip.epss.dao.AdminMapper;

@Service(value = "adminService")
public class AdminService {
    @Autowired
    private AdminMapper adminMapper;

    public AdminMapper getAdminMapper() {
        return adminMapper;
    }

    public void setAdminMapper(AdminMapper adminMapper) {
        this.adminMapper = adminMapper;
    }

    public void testMethod1(){
        System.out.println("AdminService testMethod1().............");
        adminMapper.test1();
    }
    public int testMethod2(){
        System.out.println("AdminService testMethod2().............");
        adminMapper.test1();
        return 1;
    }
}

```

### 4	编写测试代码

```java
import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import vip.epss.service.AdminService;

public class TestSpringAop {
    @Test
    public void testSpringAopByAnnotation(){
        //通过读取spring配置文件拿到IOC容器
        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        //通过IOC容器拿到 Bean
        AdminService adminService = classPathXmlApplicationContext.getBean("adminService", AdminService.class);
        //使用Bean
        adminService.testMethod1();//模拟未切入的操作
        adminService.testMethod2();//模拟切入的操作
    }
}

```

### 5	使切面生效配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--    开启自动扫描，将@Component,@Repostroy,@Service,@Controller纳入到IOC-->
    <context:component-scan base-package="vip.epss"></context:component-scan>
<!--    声明面向方面的代码都可以自动-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
<!--    <bean id="adminMapper" class="vip.epss.dao.AdminMapper" scope="singleton"></bean>-->
<!--    <bean id="adminService" class="vip.epss.service.AdminService">-->
<!--        <property name="adminMapper" ref="adminMapper"></property>-->
<!--    </bean>-->
</beans>
```



![image-20221129105945741](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221129105945741.png)

## 总结

### 1	5个通知  round开始--》before--》真实方法--》afterReturing--》after--》round结束

### 2	所有的通知都有默认参数



## 使用XML实现AOP【实用】

# Spring集成MyBatis

## 1	导入依赖包

1.1	mysql驱动包

1.2	spring-jdbc包【在spring的配置中JDBC】

1.3	mybatis- spring  交互的包 【mybatis想加入spring生态圈，遵守接口】

1.4	spring-tx包【事务，需要jdbc】{可选}

1.5	mybatis包

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <parent>
        <artifactId>frame</artifactId>
        <groupId>vip.epss</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>
    <artifactId>day20221129</artifactId>
    <packaging>war</packaging>
    <name>day20221129 Maven Webapp</name>
    <url>http://maven.apache.org</url>

    <properties>
        <!-- spring 版本号，便于统一处理多个模块，  -->
        <spring.version>5.2.8.RELEASE</spring.version>
    </properties>

    <dependencies>
        <!--        mysql 数据库依赖-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.31</version>
        </dependency>
        <!--        mybatis依赖-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.8</version>
        </dependency>
        <!--S        Lombok插件依赖-->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.10</version>
            <scope>provided</scope>
        </dependency>
        <!--E        Lombok插件依赖-->
        <!-- 使用log4j输出更多的日志信息 -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.12</version>
            <scope>compile</scope>
        </dependency>

        <!-- 代码生成工具jar , 逆向工程包-->

        <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
        </dependency>

        <!-- 此依赖会关联引用Spring中的所有基础jar包，利用了maven自动依赖管理，导入所有的spring的核心包 -->
<!--        核心包：bean，core，context，spEL（Expression）-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${spring.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-test</artifactId>
            <version>${spring.version}</version>
        </dependency>

<!--        aop的相关依赖-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aop</artifactId>
            <version>${spring.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
            <version>${spring.version}</version>
        </dependency>

<!--        aop的织入包-->
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.8.7</version>
        </dependency>

<!--        Spring整合MyBatis-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-jdbc</artifactId>
            <version>${spring.version}</version>
        </dependency>
        <dependency>
<!--            由ORM厂商提供-->
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.5</version>
        </dependency>

    </dependencies>
    <build>
        <finalName>day20221129</finalName>

        <!--        发布资源-->
        <resources>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>false</filtering>
            </resource>
        </resources>
    </build>
</project>

```

## 2	给dao层的接口添加@Mapper，纳入到IOC

```java
package vip.epss.dao;

import org.apache.ibatis.annotations.Mapper;
import vip.epss.domain.Admin;
import vip.epss.domain.AdminExample;

@Mapper
public interface AdminMapper extends CommonMapper<Admin,AdminExample> {

    //新增加的方法接口
    Admin selectByPrimaryKeyWithObject(Integer id);
}
```

## 3	配置Spring 配置文件， 托管MyBatis

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--    开启自动扫描，将@Component,@Repostroy,@Service,@Controller纳入到IOC-->
    <context:component-scan base-package="vip.epss"></context:component-scan>
<!--    声明面向方面的代码都可以自动-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
<!--    <bean id="adminMapper" class="vip.epss.dao.AdminMapper" scope="singleton"></bean>-->
<!--    <bean id="adminService" class="vip.epss.service.AdminService">-->
<!--        <property name="adminMapper" ref="adminMapper"></property>-->
<!--    </bean>-->

    <!-- 引入db配置文件  -->
    <context:property-placeholder location="db.properties" />
    <!-- 配置dataSource数据源 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="${driver}"></property>
        <property name="url" value="${url}"></property>
        <property name="username" value="${user}"></property>
        <property name="password" value="${password}"></property>
    </bean>
    <!-- 创建SqlSessionFactory，并配置实体对象别名 -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
<!--        依赖注入， 数据源-->
        <property name="dataSource" ref="dataSource"></property>
<!--        依赖注入， 实体类的别名映射-->
        <property name="typeAliasesPackage" value="vip.epss.domain" />
    </bean>
    <!-- 配置Mapper，自动扫描Mapper接口，并为其注入SqlSessionFactory -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="vip.epss.dao"></property>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property>
    </bean>
</beans>
```

## 4	测试代码

```java
import org.junit.Test;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import vip.epss.service.AdminService;
import vip.epss.service.BusinessService;

import java.io.IOException;

public class TestSpringMyBatis {

    @Test
    public void testSpringAndMyBatis(){
//        //通过读取spring配置文件拿到IOC容器
        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
//        //通过IOC容器拿到 Bean
        AdminService adminService = classPathXmlApplicationContext.getBean("adminService", AdminService.class);
//        //使用Bean
        Integer i = adminService.deleteByPrimaryKey(3);
        System.out.println(i);
    }


}

```



# 课程回顾

练习DI【依赖注入】，给IOC容器添加对象

AOP：源码不改变，增强功能【Servlet--Filter（增强request，response对象（Controller）），代理模式（经纪人做增强的工作，演员负责演戏），AOP（把增强的代码切入到指定切入点，使用钩子函数）】



# 声明式事务处理机制

## 事务处理是数据库操作的常规应用，可以借助于框架解决问题。

## AOP可以方便的切入业务应用

## 通过xml配置的方式将框架事务代码切入到自己业务



# web多层架构和MVC模式

![image-20221130132454077](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221130132454077.png)



## 传统Serlvet存在的缺陷

### 1	传统Servlet靠不同的类实现功能区分--繁琐

## 2	获取数据需要手工处理，手工转型



由框架springMvc可以取代繁琐的Servlet开发

# 关于SpringMvc

推荐Spring家族的SpringMvc实现Controller，整合方便

SpringMvc中存在超级Servlet，DispathcerServlet处理所有的请求，

![image-20221130134625050](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221130134625050.png)



SpringMvc是Spring的子模块，所以Spring如何配置，SpringMvc类似

# 案例：SpringMvc

## 1	创建web类maven工程

## 2	添加依赖

```xml
<!-- spring-webmvc会依赖spring-web -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>${spring.version}</version>
        </dependency>
```

## 3	配置DispatcherServlet



















![image-20221130145309882](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221130145309882.png)





# 注解

## @ResponseBody

返回原始数据给请求者，适合于返回json等数据

@ResponseBody可以用以修饰方法，也可以修饰类。



## @RequestMapping注解

用于建立请求URL和处理器方法之间的对应关系

也可以修饰类，可以用以修饰方法，最终url拼接结果

注意：   /xxx       /代表应用根目录

可以利用  虚拟路径   组织站点访问结构

可以使用  method  匹配对应的 HTTP方法【可以RESTful】

@GetMapping与@PostMapping   是  @RequestMapping  快捷方式



# 课堂练习：   测试@ResponseBody，@RequestMapping  的功能【9：45】



# 参数和返回值

1	接收Java类型数据，证明可以将前端传送的数据自动转型【Servlet需要手动转型】

如果接收类型为数组【接收同名多个变量】，通常用于复选框

2	前端传送的数据变量名和后端不一致，@RequestParam 进行映射处理， value指定前端的名字， required设定是否必须提供该参数，当required为false的时候可以通过 defaultValue设置默认值

3	前端传送的数据会根据变量名自动封装到对象，前端变量名和要封装的类成员属性名一致。需要使用类的getter和setter ， 成员属性是对象类型，可以使用    .   进行多层封装

4	本质上就是对 request对象 和 response对象 处理的结果，例如设置返回的头信息，处理session。Controller修饰的类会被SpringMvc注册到IOC，自动DI单例web对象【9大对象 】，开发时需要使用Servlet对象需要导入servlet-api包

5	springMVc默认返回字符串按照视图名称处理【采用的是转发方式】

# 课堂练习：接收java类型和数组类型【自动封装】

# 课堂练习：对象的多层自动封装【11：00】

# 课堂练习：利用实现登录功能【login.jsp 登录页面   ,   manager.jsp管理页面】，登录成功转到管理页面，失败回到登录页面



# 课堂练习： 实现admin的管理首页课间休息： 【14：10】



# 封装数据

Model   仅封装数据

View	仅封装视图

ModelAndView	封装视图和数据



# 视图展示【jsp+JSTL】

1	导入依赖包

```xml
<!--        需要原生的servlet实现部分功能-->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>4.0.1</version>
        </dependency>
        <!--        jsp渲染数据-->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.0</version>
        </dependency>
<!--        JSTL标签库-->
        <dependency>
            <groupId>jstl</groupId>
            <artifactId>jstl</artifactId>
            <version>1.2</version>
        </dependency>
```



2	编写视图页

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
.......
    
    
    <%--展示数据--%>
    <table border="1">
        <thead>
            <tr>
                <th>序号</th>
                <th>id</th>
                <th>姓名</th>
            </tr>
        </thead>
        <tbody>
        <%   //request    获取9大对象【servletContext例外】， 通过request可以获取其他对象  %>
<%--            循环产生在行上  ， JSTL 标签库 ，  默认访问4个作用域(scope)  page,request,session ,context --%>
            <c:forEach items="${requestScope.adminList}" var="admin" varStatus="status">
            <tr>
                <td>${status.count}</td>
                <td>${admin.id}</td>
                <td>${admin.adminname}</td>
            </tr>
            </c:forEach>
        </tbody>
    </table>
```





# 添加【课堂练习：  10：00】



![image-20221202093512440](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221202093512440.png)

![image-20221202095522530](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221202095522530.png)



# 缺陷分析

1	多页面，安全目录，跳转逻辑复杂

2	接口复杂 /admin【/add ,   /addF   , /upd,  /update, /del  , /index  】



# 课堂练习：实现完整的CRUD



# RESTful

实现HTTP状态语义化描述【语义化标签nav取代div，danger--红色】

是一种为了让信息在互联网上**顺利传递**而设计的软件架构风格，即一种采用标准URI进行调用的规范。

## 如何实现：

1	url 符合REST风格：     login.do或login.action  ==>      /admin/add     ===>/admin/opt       

2	依靠不同的HTTP方法区分业务，常用get和post

| 传统方式           | 操作      | REST风格     | HTTP方法 |
| ------------------ | --------- | ------------ | -------- |
| /admin/add         | 增加操作C | /admin/opt   | POST     |
| /admin/list?id=3   | 查询操作R | /admin/opt/3 | GET      |
| /admin/update?id=3 | 修改操作U | /admin/opt/3 | PUT      |
| /admin/del?id=3    | 删除操作D | /admin/opt/3 | DELETE   |



## 案例：

1	web.xml中配置 映射路径为      /

```xml
  <servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 也可不配置参数，默认加载 /WEB-INF/springmvc-servlet.xml -->
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>
  </servlet>

  <servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>
```



2	Controller中 编写增删改查 

```java
package vip.epss.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;
import vip.epss.domain.Admin;

@Controller
@RequestMapping(value = "/adminrest")
public class AdminRestController {
    @RequestMapping(value = "/opt",method = {RequestMethod.POST})
    public ModelAndView add(Admin admin){
        return null;
    }
    @DeleteMapping(value = "/opt/{aid}")
    public ModelAndView delete(@PathVariable("aid") Integer id){
        return null;
    }
    @PutMapping(value = "/opt/{aid}")
    public ModelAndView update(@PathVariable("aid") Integer id,Admin admin){
        return null;
    }

    @GetMapping(value = "/opt/{aid}") //REST携带数据，使用{}占位  ，此时aid为路径变量 ,仅仅用于springMVC路由标记
    public ModelAndView get(@PathVariable("aid") Integer id){
        System.out.println(id);
        return null;
    }
}

```

3	配置服务器支持其他方法

```xml
<!--使⽤Rest风格的URI，将页⾯普通的post请求转为指定的delete或者put请求-->
  <filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
  </filter>

  <filter>
    <filter-name>HttpPutFormContentFilter</filter-name>
    <filter-class>org.springframework.web.filter.HttpPutFormContentFilter</filter-class>
  </filter>
```

4	客户端表单的处理

默认只有get和post，利用post时隐藏表单域传递具体方法【Ajax无需考虑，ajax都可以指定HTTP方法】

```html
<%--测试REST风格的设计--%>
    <a href="http://localhost:8888/day20221130_war/adminrest/opt/5">REST查(GET)</a>

    <form method="post" action="http://localhost:8888/day20221130_war/adminrest/opt">
        <input type="text" name="adminname"/>
        <input type="text" name="password" />
        <input type="submit" value="验证REST增(POST)" />
    </form>

    <form method="post" action="http://localhost:8888/day20221130_war/adminrest/opt/5">
        <input type="hidden" name="_method" value="DELETE" />
        <input type="submit" value="验证REST删(DELETE)" />
    </form>

    <form method="post" action="http://localhost:8888/day20221130_war/adminrest/opt/5">
        <input type="hidden" name="_method" value="PUT" />
        <input type="text" name="adminname" />
        <input type="text" name="password" />
        <input type="submit" value="验证REST改(UPDATE)" />
    </form>
```



# 关于HTTP



http  1.0      get/post

http   1.1    7种方法，浏览器肯定支持get/post

http	2.0    都支持



# 关于后期安排

原计划： 12月24放假【实训活动结束】，预留了1周项目辅导【毕设】

变化：12月17放假

采取加课： 

![image-20221204081108294](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204081108294.png)



## 内容安排：

Spring，SpringBoot，  Vue高级，软件测试







# 上课回顾20221204：

## 1	后端路由：视图存在安全需求（放在安全目录WEB-INF），转发【forward：,默认可不写，URL不会改变，视图解析器生效】和重定向【redirect：，显式设置，根据url类型处理】的使用。

## 2	REST风格：HTTP语义化，URI相同利用不同的HTTP方法区分不同的业务【get--查询，post--添加，delete--删除，put--修改】  ， 接口简单    /admin/opt  



#  遇到问题

## 1	REST风格，默认浏览器不易测试【ajax访问可以通过type指定HTTP方法】

## 2	接口过多不便于回归测试

## 解决方式：使用接口测试工具    ，测试HTTP 推荐使用   postMan   ,    apiTest







# PostMan的使用

## 1	下载并安装    注册免费试用

## 2	功能介绍

![image-20221204091353557](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204091353557.png)

## 3	创建collection

![image-20221204092049923](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204092049923.png)

## 4	创建测试用例

![image-20221204093413961](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204093413961.png)



## 5	单独运行测试用例或者批量计划运行

![image-20221204095254165](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204095254165.png)





# 不足分析：主要用于web类型的测试。典型的接口测试工具【功能】，不能实现压力测试。



# 课堂练习：编写当前项目的多条测试用例【1：普通的HTTP请求，2：向同一接口发送GET、POST、DELETE、PUT请求，实现不同响应】，安排每日8：00执行测试脚本【提供运行截图】 -- 10：45  提交





# 当下流行的开发技术

![image-20221204104918072](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204104918072.png)

### 实现：原生XMLHttpRequest，Promise,jQuery,Vue-resources,Axios.



# SpringMVC接收JSON

### 1	JSON是JavaScript对象表示法，基本的Key：Value  ，可以被识别为Java对象，网络传输的都是bit位，需要解析的方式【jackson，data-bind】。

## 2	实现前后端分离，代表2个项目【前端项目和后端项目】，需要解决跨域问题【依据：ip不同、端口不同、主机名不同】

![image-20221204110358250](%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20221204110358250.png)

## 3	推荐解决方法， 试用servlet的组件之一   Filter过滤器。



# 跨域过滤器实现

## 1	导入Servlet-api包， 因为需要使用 Filter 组件

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
</dependency>
```



## 2	创建过滤器

```java
package vip.epss.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

//想成为一个Filter，必须要实现Filter接口, 覆写方法
//@WebFilter     //无法控制过滤器的顺序
public class CROSFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        Filter.super.init(filterConfig);
        System.out.println("跨域过滤器初始化.....");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("跨域过滤器开始工作.....");
        //跨域的本质就是修改响应对象response的头信息
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;
        //设置允许跨域
        httpServletResponse.setHeader("Access-Control-Allow-Origin",httpServletRequest.getHeader("Origin"));
        //设置开启Cookie
        httpServletResponse.setHeader("Access-Control-Allow-Credentials", "true");
        //返回到过滤器链，才可以继续处理
        filterChain.doFilter(httpServletRequest,httpServletResponse);
    }

    @Override
    public void destroy() {
        Filter.super.destroy();
        System.out.println("跨域过滤器销毁.....");
    }
}

```



## 3	应用过滤器(web.xml)

```xml
<!--  过滤器的顺序按照filter的标签顺序进行的-->
  <filter>
    <filter-name>CrosFilter</filter-name>
    <filter-class>vip.epss.filter.CROSFilter</filter-class>
  </filter>


  <filter-mapping>
    <filter-name>CrosFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>

```



## 4	创建Controller方法接收AJAX请求

```java
package vip.epss.controller;

import org.springframework.web.bind.annotation.*;
import vip.epss.domain.Admin;

@RequestMapping("/adminar")
@RestController   //  @Controller 和  @ResponseBody 合体
public class AdminAjaxRestController {

    @GetMapping(value = "/opt/{aid}")
    public String get(@PathVariable("aid")Integer id){
        return id.toString();
    }

    @PostMapping(value = "/opt")
    public String add(Admin admin){
        System.out.println(admin);
        return admin.toString();
    }


}


```

## 5	客户端发送请求

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id="aBtn1">发送ajax get请求</button>
    <button id="aBtn2">发送ajax post请求</button>
<script>
    window.onload = function(){
        document.querySelector("#aBtn2").onclick = function(){
            let mydata = {//json的标准格式    'Key'：value
                'adminname':'zhangsan',
                'password':'123456',
                'info.phone':'13898647536'
            };
            let xhr = new XMLHttpRequest();
            
            let url = "http://localhost:8888/day20221130_war/adminar/opt";
            // let url = "http://localhost:8888/day20221130_war/adminar/opt?adminname=zhangsan&password=123456&info.phone=13898647536";
            xhr.open("post",url,true);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8');
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4 && xhr.status == 200){
                    console.log(xhr.responseText);
                }
            }
            // xhr.send(JSON.stringify(mydata));   //服务器端无法识别
            xhr.send("adminname=zhangsan&password=123456&info.phone=13898647536"); //对应  22 行代码
            // xhr.send();  //对应    23 行代码
        };

        document.querySelector("#aBtn1").onclick = function(){
            let xhr = new XMLHttpRequest();
            let url = "http://localhost:8888/day20221130_war/adminar/opt/666";
            xhr.open("get",url,true);
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4 && xhr.status == 200){
                    console.log(xhr.responseText);
                }
            }
            xhr.send();
        };
    };
</script>
</body>
</html>
```





# 课堂练习：  前后端分离实现跨域请求，能够实现get和post访问后端接口【13：50】



# 课堂练习： 完成jQuery实现ajax   delete方式访问后端REST接口【14：45】

























# 







# 项目辅导【回答问题阶段】





# 上课回顾20221205

## 1	REST风格编程，利用HTTP不同方法的语义。

## 2	AJAX跨域问题







# Controller中handler方法的返回值

## 1	如果不是前后端分离项目（一般 @Controller修饰类）

### 1.1	返回类型是String

#### 1.1.1	默认是转发到字符串的地址【结合视图解析器】， return "abc/k"    等同于    return  "forward:abc/k"   ,结合视图解析器拼接为   "/WEB-INF/abc/k.jsp"  

#### 1.1.2	直接重定向，  return  "redirct:abc/k"(相对地址)  或   return "redirect:http://www.baidu.com" （绝对地址） ,  直接让客户端重定向到    当前地址/abc/k  或者   外部百度地址。

### 1.2	返回类型ModelAndView（Model，View）

#### View 可以使用转发或者重定向（View和返回值String是相同）  ，    Model中可以添加数据， 转发时model被携带在request中转发到下一个Servlet ， 重定向时model被携带在response给客户端。



## 2	如果是前后端分离项目（一般 @Controller + @ResponseBody == @RESTController  修饰类）

## 2.1	返回类型是String，只适合简单业务（不建议）

### 2.2	返回复合类型数据结构，需要一种机制能够自动把复合类型序列化为JSON字串

### 2.3	如果不能确定最终类型，建议再次包装	







## 案例：返回复合类型

## 1	依赖JSON封装工具

```xml
<!--和前端交互时能够自动封装解封装JSON格式，通常使用getter和setter实现-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.10.0</version>
</dependency>
```

## 2	handler处理器方法只需要返回java类型自动封装为JSON格式 （基本类型--》基本类型，顺序集合和set--》数组，map--》对象）

```java
@GetMapping(value = "/opt/{aid}")
    public List<Admin> get(@PathVariable("aid")Integer id){
        ArrayList<Admin> admins = new ArrayList<>();
        admins.add(new Admin(1,"a","123",null,null));
        admins.add(new Admin(2,"b","123",null,null));
        admins.add(new Admin(3,"c","123",null,null));
//        return admins.get(id);//返回一个
        return admins;//返回一个
        /*if(id < 0){//需要集合元素

        }else{//需要单一元素

        }*/
        //return "get:"+id.toString();
    }
```



# 课堂练习： get返回单个  或者  集合   的Admin【9：30】



# 实现自己的通用封装类型，所有返回给前端的数据都是用该标准包格式

```java
package vip.epss.utils;
//通用的数据封装格式

import java.util.HashMap;
import java.util.Map;

public class MessageAndData {
    private String message;//说明信息
    private Integer statusCode;//状态码
    //仿照通信协议实现  1xx 协商，  2xx 成功，3xx  重定向，  4xx  访问资源 ，5xx  服务器问题
    private Map<String,Object> dataZone = new HashMap<>();//万能容器

    public Map<String, Object> getDataZone() {
        return dataZone;
    }

    public void setDataZone(Map<String, Object> dataZone) {
        this.dataZone = dataZone;
    }

    public String getMessage() {
        return this.message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Integer getStatusCode() {
        return this.statusCode;
    }

    public void setStatusCode(Integer statusCode) {
        this.statusCode = statusCode;
    }

    //作为一个工具类，应该要方便调用，使用类方法static比较合适
    public static MessageAndData success(String msg){
        MessageAndData messageAndData = new MessageAndData();
        messageAndData.setStatusCode(200);
        messageAndData.setMessage(msg);
        return messageAndData;
    }
    public static MessageAndData success(Integer sc){
        MessageAndData messageAndData = new MessageAndData();
        messageAndData.setStatusCode(sc);
        messageAndData.setMessage("成功");
        return messageAndData;
    }
    public static MessageAndData success(String msg,Integer sc){
        MessageAndData messageAndData = new MessageAndData();
        messageAndData.setStatusCode(sc);
        messageAndData.setMessage(msg);
        return messageAndData;
    }
    public static MessageAndData success(){//工厂方法
        MessageAndData messageAndData = new MessageAndData();
        messageAndData.setStatusCode(200);
        messageAndData.setMessage("成功");
        return messageAndData;
    }
    public static MessageAndData error(){//工厂方法
        MessageAndData messageAndData = new MessageAndData();
        messageAndData.setStatusCode(404);
        messageAndData.setMessage("失败");
        return messageAndData;
    }

    public MessageAndData addData(String keyname,Object val){
        dataZone.put(keyname,val);
        return this;//支持链式编程
    }
}

```





# 课堂练习：实现自己的通用封装类型【10：55】









# 上传文件案例

## 1	导入依赖包

```xml
<!--        文件上传-->
        <dependency>
            <groupId>commons-fileupload</groupId>
            <artifactId>commons-fileupload</artifactId>
            <version>1.2.2</version>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.4</version>
        </dependency>
```

## 2	配置上传解析器

HTTP上传文件， 会将HTTP的body部分划分为多个段，

```xml
<!--必须要有此id名,multipartResolver   不能自行设置 -->
<bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <!--上传文件大小限制，单位：字节 -->
    <property name="maxUploadSize" value="5000000"></property>
</bean>
```



## 3	配置处理方法

```java
	@ResponseBody
    @PostMapping(value = "/upload")
    public String upload(MultipartFile upfile) {
        //上传图片存储目录
        String path = "c:/b/upload";
        //获取文件名并使用UUID生成新文件名
        String fileName = upfile.getOriginalFilename();
        String newFileName = UUID.randomUUID() + fileName.substring(fileName.lastIndexOf("."));
        //在指定上传图片存储目录中创建新文件
        File targetFile = new File(path, newFileName);
        //如果找不到指定目录和文件，就新创建此目录和文件
        if (!targetFile.exists()) {
            targetFile.mkdirs();
        }
        //将文件写入硬盘（myFile在内存中）
        try {
            upfile.transferTo(targetFile);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "ok";
    }
```

## 4	编写客户端代码

```html
   <form method="post" action="http://localhost:8888/day20221130_war/admin/upload" enctype="multipart/form-data">
        <input type="file" name="upfile" />
        <input type="submit" value="上传" />
    </form>

```



# 课堂练习：  使用SpringMVC的解析器上传文件











# 上传多个文件[封装工具类]

## 1	前端多个文件表单使用同一个name值（类似复选框模式）

```html
<form method="post" action="http://localhost:8888/day20221130_war/admin/uploads" enctype="multipart/form-data">
    <input type="file" name="upfiles" />
    <input type="file" name="upfiles" />
    <input type="file" name="upfiles" />
    <input type="submit" value="上传多个文件" />
</form>
```

## 2	后端处理器能够接收多个同类型数据（数组）

```java
@ResponseBody
    @PostMapping(value = "/uploads")
    public MessageAndData uploads(MultipartFile[] upfiles) {
        List<String> retFileName = new ArrayList<>();
        //处于健壮性考虑， 确保上传的文件合理
        if(upfiles!=null && upfiles.length > 0){//满足需要上传的条件
            //上传图片存储目录,允许业务类程序员指定
            String path = "c:/b/upload";
            //循环遍历上传文件
            for (int i = 0; i < upfiles.length; i++) {
                retFileName.add(UpUtils.saveFile(upfiles[i],path));
            }
            System.out.println(retFileName);
        }
        return MessageAndData.success("上传成功").addData("ups",retFileName);
    }
```

## 3	工具类的设计和实现   

```java
package vip.epss.utils;

import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.util.UUID;

//上传文件的工具类
public class UpUtils {
    public static String saveFile(MultipartFile upfile,String path){
        //获取文件名并使用UUID生成新文件名
        String fileName = upfile.getOriginalFilename();
        String newFileName = UUID.randomUUID() + fileName.substring(fileName.lastIndexOf("."));
        //在指定上传图片存储目录中创建新文件
        File targetFile = new File(path, newFileName);
        //如果找不到指定目录和文件，就新创建此目录和文件
        if (!targetFile.exists()) {
            targetFile.mkdirs();
        }
        //将文件写入硬盘（myFile在内存中）
        try {
            upfile.transferTo(targetFile);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return newFileName;
    }
}

```





# 上课回顾20221206

## 1	handler返回值，String，ModelAndView，集合框架，自定义

## 2	上传文件,上传解析器，工具类的编写











# 上传文件带参数



## 1	实现客户端的功能



## 2	实现服务端的功能【2.1	服务端分割拼接，   2.2   客户端分割拼接】

# 【课堂练习   10：00】

















